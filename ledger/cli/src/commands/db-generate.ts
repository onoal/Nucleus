/**
 * db:generate Command
 *
 * Automatically discovers schemas from modules and generates Drizzle config and migrations.
 *
 * @module commands/db-generate
 */

import { readFileSync, writeFileSync, existsSync } from "fs";
import { join } from "path";
import { execSync } from "child_process";
import chalk from "chalk";

/**
 * Discover modules from package.json dependencies
 */
export async function discoverModules(projectPath: string): Promise<string[]> {
  const packageJsonPath = join(projectPath, "package.json");

  if (!existsSync(packageJsonPath)) {
    throw new Error(`package.json not found at ${packageJsonPath}`);
  }

  const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf-8"));

  // Find all @onoal/ledger-module-* packages
  const allDeps = {
    ...(packageJson.dependencies || {}),
    ...(packageJson.devDependencies || {}),
  };

  const modules = Object.keys(allDeps)
    .filter((dep) => dep.startsWith("@onoal/ledger-module-"))
    .map((dep) => dep.replace("@onoal/ledger-module-", ""));

  return modules;
}

/**
 * Detect database provider from package.json
 */
export function detectProvider(
  projectPath: string
): "postgres" | "sqlite" | "d1" {
  const packageJsonPath = join(projectPath, "package.json");

  if (!existsSync(packageJsonPath)) {
    return "sqlite"; // Default
  }

  const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf-8"));
  const allDeps = {
    ...(packageJson.dependencies || {}),
    ...(packageJson.devDependencies || {}),
  };

  if (allDeps["@onoal/ledger-database-cloudflare-d1"]) {
    return "d1";
  }
  if (allDeps["@neondatabase/serverless"] || allDeps["pg"]) {
    return "postgres";
  }
  return "sqlite"; // Default
}

/**
 * Generate ledger.config.ts with all discovered schemas
 */
export async function generateLedgerConfig(
  projectPath: string,
  modules: string[]
): Promise<void> {
  const configPath = join(projectPath, "ledger.config.ts");

  // Check if config exists
  if (existsSync(configPath)) {
    console.log("‚ö†Ô∏è  ledger.config.ts already exists, skipping generation");
    return;
  }

  // Generate imports
  const imports = [
    `import { ledgerCoreSchema } from "@onoal/ledger-core/schema";`,
    ...modules.map(
      (m) => `import { ${m}Schema } from "@onoal/ledger-module-${m}/schema";`
    ),
  ];

  // Generate schema merge
  const schemaMerge = [
    "...ledgerCoreSchema",
    ...modules.map((m) => `...${m}Schema`),
  ];

  const configContent = `${imports.join("\n")}

/**
 * Ledger schema configuration
 * 
 * Auto-generated by db:generate command.
 * Contains all core and module schemas.
 */
export const schema = {
  ${schemaMerge.join(",\n  ")},
};

export default schema;
`;

  writeFileSync(configPath, configContent);
  console.log("‚úÖ Generated ledger.config.ts");
}

/**
 * Generate drizzle.config.ts for Drizzle Kit
 */
export async function generateDrizzleConfig(
  projectPath: string,
  options: {
    provider: "postgres" | "sqlite" | "d1";
    outDir?: string;
  }
): Promise<void> {
  const drizzleConfigPath = join(projectPath, "drizzle.config.ts");

  const driver =
    options.provider === "postgres"
      ? "pg"
      : options.provider === "sqlite"
        ? "better-sqlite3"
        : "d1";

  const dbCredentials =
    options.provider === "postgres"
      ? `connectionString: process.env.DATABASE_URL!,`
      : options.provider === "sqlite"
        ? `url: "./ledger.db",`
        : `databaseId: process.env.D1_DATABASE_ID!,`;

  const configContent = `import type { Config } from "drizzle-kit";
import { schema } from "./ledger.config.js";

/**
 * Drizzle Kit configuration
 * 
 * Auto-generated by db:generate command.
 * Used by drizzle-kit to generate migrations.
 */
export default {
  schema: schema,
  out: "${options.outDir || "./drizzle"}",
  driver: "${driver}",
  dbCredentials: {
    ${dbCredentials}
  },
} satisfies Config;
`;

  writeFileSync(drizzleConfigPath, configContent);
  console.log("‚úÖ Generated drizzle.config.ts");
}

/**
 * Main db:generate command
 */
export async function dbGenerate(options: {
  projectPath?: string;
  provider?: "postgres" | "sqlite" | "d1";
  config?: string;
  outDir?: string;
}): Promise<void> {
  const projectPath = options.projectPath || process.cwd();
  const configPath = options.config || join(projectPath, "ledger.config.ts");

  console.log(chalk.blue.bold("\nüîç Generating Database Schema\n"));

  // 1. Discover modules from package.json
  console.log(chalk.cyan("Discovering modules..."));
  const modules = await discoverModules(projectPath);
  console.log(
    chalk.green(
      `üì¶ Found ${modules.length} module(s): ${modules.join(", ") || "none"}`
    )
  );

  // 2. Check if ledger.config.ts exists, generate if not
  if (!existsSync(configPath)) {
    console.log(chalk.yellow("‚ö†Ô∏è  ledger.config.ts not found, generating..."));
    await generateLedgerConfig(projectPath, modules);
  } else {
    console.log(chalk.green("‚úÖ ledger.config.ts already exists"));
  }

  // 3. Detect or use provided provider
  const provider = options.provider || detectProvider(projectPath);
  console.log(chalk.cyan(`üóÑÔ∏è  Using database provider: ${provider}\n`));

  // 4. Generate drizzle.config.ts
  await generateDrizzleConfig(projectPath, {
    provider,
    outDir: options.outDir || "./drizzle",
  });

  // 5. Run drizzle-kit generate
  console.log(chalk.yellow("üîÑ Generating migrations...\n"));
  try {
    execSync("pnpm drizzle-kit generate", {
      cwd: projectPath,
      stdio: "inherit",
    });
    console.log(chalk.green("\n‚úÖ Migrations generated successfully!"));
    console.log(
      chalk.cyan(
        "\nüí° Next step: Run 'onoal db:migrate' to apply migrations to your database.\n"
      )
    );
  } catch (error) {
    console.error(chalk.red("\n‚ùå Failed to generate migrations:"), error);
    process.exit(1);
  }
}
